# -*- coding: utf-8 -*-
"""Project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cwvJzmMkVTLYcru4ixsyJLyX0JWEwKi3

Names: Richard Cai (rjc432), Wenkai Zhao (wz459)

Topic:


1.   Effect of exports of different natural resources on curruption index and/or country's economy. Read on the "[resource curse](https://wikipedia.org/wiki/resource_curse)" and "[dutch disease](https://wikipedia.org/wiki/dutch_disease)" on [Wikipedia.org](https://Wikipedia.org).
2.   List item



Dataset Source: Plan on using [comtradeplus.un.org](https://comtradeplus.un.org)
[Oil dataset](https://comtradeplus.un.org/TradeFlow?Frequency=A&Flows=X&CommodityCodes=2709&Partners=0&Reporters=all&period=all&AggregateBy=none&BreakdownMode=plus)

**Abstract:**

**Write-Up:**

1.   We wish to prove or disprove that increased HDI is correlated with increased raw resource exports.
2.   We wish to able to fit a trendline to a graph of HDI vs resource exports.
3.   We wish to develop a score that measures how badly a country has used its resource exports.
"""

import numpy as np
import pandas as pd
from sklearn.metrics import recall_score
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn import tree
from sklearn import datasets
from sklearn.cluster import KMeans
from sklearn.metrics import r2_score
import matplotlib.pyplot as plt
from sklearn.svm import SVC
import seaborn as sns

# from google.colab import drive
# drive.mount('/content/drive')
# df = pd.read_csv('/content/drive/My Drive/INFO 1998 Project/cleanedcoaldata.csv')

creals = pd.read_csv("/content/HDI Resource Combined/RCereals.csv_with_HDI.csv")
inorganic = pd.read_csv("/content/HDI Resource Combined/RInorganic.csv_with_HDI.csv")
mineral = pd.read_csv("/content/HDI Resource Combined/RMineral.csv_with_HDI.csv")
ores = pd.read_csv("/content/HDI Resource Combined/ROres.csv_with_HDI.csv")
wood = pd.read_csv("/content/HDI Resource Combined/RWood.csv_with_HDI.csv")

all_exports = [cereals,inorganic,mineral,ores,wood]

print(cereals.head())
print(inorganic.head())
print(mineral.head())
print(ores.head())
print(wood.head())

print(cereals.size)
print(inorganic.size)
print(mineral.size)
print(ores.size)
print(wood.size)

fig2D = plt.figure()

# plt.acorr()

plt.scatter(cereals['dollar_value'],cereals['HDI_value'])

plt.title('dollar_value vs HDI_value for cereals')
plt.xlabel('HDI_value')
plt.ylabel('dollar_value')

plt.show()

plt.hist(cereals['HDI_value'], 50, align='mid')
# Add a title
plt.title('HDI Frequency')
# Add x and y labels
plt.xlabel('HDI')
plt.ylabel('Frequency')
# Show the plot!
plt.show()

# Calculate the correlation for each resource
labels = ['Cereals', 'Inorganic', 'Mineral', 'Ores', 'Wood']
correlation_df = pd.DataFrame(index=labels, columns=['HDI Correlation'])
for data, label in zip(all_exports, labels):
    # Ensure both columns are numeric before calculating correlation
    correlation = data['dollar_value'].astype(float).corr(data['HDI_value'].astype(float))
    correlation_df.loc[label, 'HDI Correlation'] = correlation
print(correlation_df.iloc[:, 0])

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# 统一列名
new_col_names = ['Export Amount in dollars', 'HDI Value']
datasets = [creals, inorganic, mineral, ores, wood]

for data in datasets:
    data.rename(columns={data.columns[3]: new_col_names[0], data.columns[4]: new_col_names[1]}, inplace=True)

# 颜色和标签
colors = ['red', 'blue', 'green', 'purple', 'orange']
labels = ['Cereals', 'Inorganic', 'Mineral', 'Ores', 'Wood']

# 创建散点图
plt.figure(figsize=(12, 6), dpi=100)

for data, color, label in zip(datasets, colors, labels):
    # 去除 "Export Amount in dollars" 和 "HDI Value" 为空或为 0 的行
    data_clean = data.dropna(subset=new_col_names)
    data_clean = data_clean[(data_clean[new_col_names[0]] != 0) & (data_clean[new_col_names[1]] != 0)]

    # 画散点图
    plt.scatter(data_clean[new_col_names[0]], data_clean[new_col_names[1]],
                c=color, label=label, alpha=0.7, edgecolors='k')

# 添加图例和标签
plt.xlabel("Export Amount in dollars")
plt.ylabel("HDI Value")
plt.title("Scatter Plot of Different Resource Types (Filtered Data)")
plt.legend()
plt.grid(True)

# 显示图表
plt.show()

datasets = [creals, inorganic, mineral, ores, wood]
labels = ['Cereals', 'Inorganic', 'Mineral', 'Ores', 'Wood']
colors = ['red', 'blue', 'green', 'purple', 'orange']

# Function to clean and cap HDI values
def clean_data(data):
    data_clean = data.dropna(subset=[data.columns[3], data.columns[4]])  # Remove NaN
    data_clean = data_clean[(data_clean.iloc[:, 3] != 0) & (data_clean.iloc[:, 4] != 0)]  # Remove zeros
    data_clean.iloc[:, 4] = np.clip(data_clean.iloc[:, 4], 0, 1)  # Cap HDI at 1
    return data_clean

# Correlation Analysis
print("=== Correlation Analysis ===")
for data, label in zip(datasets, labels):
    data_clean = clean_data(data)
    correlation = data_clean.iloc[:, 3].corr(data_clean.iloc[:, 4])  # Compute correlation
    print(f"Correlation in {label} dataset: {correlation:.4f}")

# Regression Analysis (HDI vs Export Amount)
plt.figure(figsize=(12, 6))
for data, color, label in zip(datasets, colors, labels):
    data_clean = clean_data(data)

    X = data_clean.iloc[:, 3].values.reshape(-1, 1)  # Feature (Export Amount)
    y = data_clean.iloc[:, 4].values  # Target (HDI Value)

    model = LinearRegression()
    model.fit(X, y)
    y_pred = model.predict(X)

    plt.scatter(X, y, color=color, alpha=0.6, label=f"{label} (R²={r2_score(y, y_pred):.2f})")
    plt.plot(X, y_pred, color=color, linestyle="dashed")

plt.xlabel("Export Amount in dollars")
plt.ylabel("HDI Value (Capped at 1)")
plt.title("Regression Analysis: Export vs HDI")
plt.ylim(0, 1)  #Limit the Y-axis range from 0 to 1
plt.legend()
plt.grid(True)
plt.show()

# Clustering Analysis (K-Means) for each dataset separately
plt.figure(figsize=(15, 10))

for i, (data, color, label) in enumerate(zip(datasets, colors, labels), 1):
    data_clean = clean_data(data)[[data.columns[3], data.columns[4]]].copy()

    # 进行 K-Means 聚类
    kmeans = KMeans(n_clusters=3, random_state=42)
    data_clean["Cluster"] = kmeans.fit_predict(data_clean)

    centroids = kmeans.cluster_centers_

    # 绘制单独的子图
    plt.subplot(2, 3, i)  # 2 行 3 列的子图布局
    sns.scatterplot(x=data_clean.iloc[:, 0], y=data_clean.iloc[:, 1], hue=data_clean["Cluster"], palette="viridis")
    plt.xlabel("Export Amount in dollars")
    plt.ylabel("HDI Value (Capped at 1)")
    plt.title(f"Clustering in {label}")
    plt.ylim(0, 1)  # 限制 Y 轴范围
    for i in range(kmeans.n_clusters):
        lines = plt.plot(centroids[i, 0], centroids[i, 1], 'kx', markersize=10)

plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.optimize import curve_fit

# Read data
file_path = "/content/RCereals.csv_with_HDI.csv"
df = pd.read_csv(file_path)

# Filter out missing values
df_filtered = df[['dollar_value', 'HDI_value']].dropna()

# Define power function model: HDI = a * (dollar_value^b)
def power_law(x, a, b):
    return a * np.power(x, b)

# Getting data
x_data = df_filtered['dollar_value'].values
y_data = df_filtered['HDI_value'].values

# Perform curve fitting
params, covariance = curve_fit(log_function, x_data, y_data, p0=[0, 0.1])

# Predictive value
x_fit = np.linspace(min(x_data), max(x_data), 100)
y_fit = log_function(x_fit, *params)

# Draw a fitting curve
plt.figure(figsize=(8, 6))
plt.scatter(x_data, y_data, alpha=0.5, label="Data")
plt.plot(x_fit, y_fit, color='red', label=f"Fitted Curve: a={params[0]:.4f}, b={params[1]:.4f}")

# Set the horizontal axis unit to 1e11
plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(1e11))
plt.xlabel("Dollar Value")
plt.ylabel("HDI Value")
plt.title("Nonlinear Regression: Log Function Fit")
plt.legend()
plt.show()

# Output fitting parameters
print(f"拟合参数: a = {params[0]:.4f}, b = {params[1]:.4f}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.optimize import curve_fit

# Read data
file_path = "/content/RInorganic.csv_with_HDI.csv"
df = pd.read_csv(file_path)

# Filter out missing values
df_filtered = df[['dollar_value', 'HDI_value']].dropna()

# Define power function model: HDI = a * (dollar_value^b)
def power_law(x, a, b):
    return a * np.power(x, b)

# Getting data
x_data = df_filtered['dollar_value'].values
y_data = df_filtered['HDI_value'].values

# Perform curve fitting
params, covariance = curve_fit(log_function, x_data, y_data, p0=[0, 0.1])

# Predictive value
x_fit = np.linspace(min(x_data), max(x_data), 100)
y_fit = log_function(x_fit, *params)

# Draw a fitting curve
plt.figure(figsize=(8, 6))
plt.scatter(x_data, y_data, alpha=0.5, label="Data")
plt.plot(x_fit, y_fit, color='red', label=f"Fitted Curve: a={params[0]:.4f}, b={params[1]:.4f}")

# Set the horizontal axis unit to 1e11
plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(1e11))
plt.xlabel("Dollar Value")
plt.ylabel("HDI Value")
plt.title("Nonlinear Regression: Power Function Fit")
plt.legend()
plt.show()

# Output fitting parameters
print(f"拟合参数: a = {params[0]:.4f}, b = {params[1]:.4f}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.optimize import curve_fit

# Read data
file_path = "/content/RMineral.csv_with_HDI.csv"
df = pd.read_csv(file_path)

# Filter out missing values
df_filtered = df[['dollar_value', 'HDI_value']].dropna()

# Define power function model: HDI = a * (dollar_value^b)
def power_law(x, a, b):
    return a * np.power(x, b)

# Getting data
x_data = df_filtered['dollar_value'].values
y_data = df_filtered['HDI_value'].values

# Perform curve fitting
params, covariance = curve_fit(log_function, x_data, y_data, p0=[0, 0.1])

# Predictive value
x_fit = np.linspace(min(x_data), max(x_data), 100)
y_fit = log_function(x_fit, *params)

# Draw a fitting curve
plt.figure(figsize=(8, 6))
plt.scatter(x_data, y_data, alpha=0.5, label="Data")
plt.plot(x_fit, y_fit, color='red', label=f"Fitted Curve: a={params[0]:.4f}, b={params[1]:.4f}")

# Set the horizontal axis unit to 1e11
plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(1e11))
plt.xlabel("Dollar Value")
plt.ylabel("HDI Value")
plt.title("Nonlinear Regression: Power Function Fit")
plt.legend()
plt.show()

# Output fitting parameters
print(f"拟合参数: a = {params[0]:.4f}, b = {params[1]:.4f}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.optimize import curve_fit

# Read data
file_path = "/content/ROres.csv_with_HDI.csv"
df = pd.read_csv(file_path)

# Filter out missing values
df_filtered = df[['dollar_value', 'HDI_value']].dropna()

# Define power function model: HDI = a * (dollar_value^b)
def power_law(x, a, b):
    return a * np.power(x, b)

# Getting data
x_data = df_filtered['dollar_value'].values
y_data = df_filtered['HDI_value'].values

# Perform curve fitting
params, covariance = curve_fit(log_function, x_data, y_data, p0=[0, 0.1])

# Predictive value
x_fit = np.linspace(min(x_data), max(x_data), 100)
y_fit = log_function(x_fit, *params)

# Draw a fitting curve
plt.figure(figsize=(8, 6))
plt.scatter(x_data, y_data, alpha=0.5, label="Data")
plt.plot(x_fit, y_fit, color='red', label=f"Fitted Curve: a={params[0]:.4f}, b={params[1]:.4f}")

# Set the horizontal axis unit to 1e11
plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(1e11))
plt.xlabel("Dollar Value")
plt.ylabel("HDI Value")
plt.title("Nonlinear Regression: Power Function Fit")
plt.legend()
plt.show()

# Output fitting parameters
print(f"拟合参数: a = {params[0]:.4f}, b = {params[1]:.4f}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.optimize import curve_fit

# Read data
file_path = "/content/RWood.csv_with_HDI.csv"
df = pd.read_csv(file_path)

# Filter out missing values
df_filtered = df[['dollar_value', 'HDI_value']].dropna()

# Define power function model: HDI = a * (dollar_value^b)
def power_law(x, a, b):
    return a * np.power(x, b)

# Getting data
x_data = df_filtered['dollar_value'].values
y_data = df_filtered['HDI_value'].values

# Perform curve fitting
params, covariance = curve_fit(log_function, x_data, y_data, p0=[0, 0.1])

# Predictive value
x_fit = np.linspace(min(x_data), max(x_data), 100)
y_fit = log_function(x_fit, *params)

# Draw a fitting curve
plt.figure(figsize=(8, 6))
plt.scatter(x_data, y_data, alpha=0.5, label="Data")
plt.plot(x_fit, y_fit, color='red', label=f"Fitted Curve: a={params[0]:.4f}, b={params[1]:.4f}")

# Set the horizontal axis unit to 1e11
plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(1e11))
plt.xlabel("Dollar Value")
plt.ylabel("HDI Value")
plt.title("Nonlinear Regression: Power Function Fit")
plt.legend()
plt.show()

# Output fitting parameters
print(f"拟合参数: a = {params[0]:.4f}, b = {params[1]:.4f}")